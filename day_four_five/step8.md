# Creating comments

In this step we are going to create a form on our individual post page, to add comments to that post.

We do this by making a `POST` request to `/posts/{post.id}/comments`.

The problems we need to solve are:
1. What data do we need to send?
2. How do we collect that data?
3. How to we trigger the http request to create a comment?


## What data do we need to send?

We know from the previous step that comments have the following structure:

```json
{
  "postId": 1,
  "id": 1,
  "name": "id labore ex et quam laborum",
  "email": "Eliseo@gardner.biz",
  "body": "laudantium enim quasi est quidem magnam voluptate ipsam eos"
}
```

Lets look at each field in turn:
- `id` - When creating an item, the `id` field is automatically generated by the server. We don't need to generate this.
- `postId` - We already know the post id that we want to add the comment to - it will be sent as part of the request URL
- `name` - needs to be collected from the user
- `email` - needs to be collected from the user
- `body` - needs to be collected from the user

## Collecting the data
To collect the name, email, and body data from the user, we will need to create a form. This should be its own component.

Create a file `components/CommentForm.js` and import it into `post.html`.

In this file, create a component function that returns the html for a form, with the appropriate input fields for collecting a name, email and longer text body, as well as a submit button.

Give each of these form elements a unique id attribute, and give the form as a whole an id of `comment-form`

<details>
  <summary>Spoiler</summary>

  ```js
function CommentForm() {
  return `
    <form id="comment-form">
      <div>
        <label for="name">
          Name:
          <input id="comment-form-name" name="name" type="text" />
        </label>
      </div>
      <div>
        <label for="email">
          Email:
          <input id="comment-form-email" name="email" type="email" />
        </label>
      </div>
      <div>
        <label for="body">
          Comment:
          <textarea id="comment-form-body" name="body"></textarea>
        </label>
      </div>
      <button id="comment-form-submit" type="submit">Submit</button>
    </form>
  `;
}
  ```
</details>

This gives us a framework for collecting the data we need. Now we just need to collect it in our JavaScript, and send it to the server when the submit button is clicked.

## Submitting the form
Whenever a user interacts with any DOM element, an event is fired. When you hover on an element, an event is fired. When you click on a button, an event is fired. By default these events are largely ignored and forgotten about. But we can tap into these to make our page interactive and respond to user input.

The mechanism for doing this is called an **event listener**, which is basically a function that is attached to a DOM element, and gets triggered whenever that element fires a particular type of event.

#### :books: - [Event Listeners](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)

The `form` element fires a `submit` event when we click on it's submit button.

So in order to make our `POST` request to create a comment when the form is submitted, we need to listen to this event on our form:

First, find the comment form element by it's `id` attribute:

```js
const commentForm = document.getElementById('comment-form');
```

To this element, add an event listener that listens to `submit` events using the `addEventListener` method:

```js
commentForm.addEventListener('submit', function(event) {
  console.log(event);
});
```

Event handler callbacks are invoked with an object representing the event. These have a lot of information in them, some of which is useful, and most of which you'll never need.

In this case, the form submit event isn't particularly interesting, but it's always worth `console.log`ging the event anyway, to see if you can use anything.

***
### Try it out!

Refresh your page, fill out the form and submit it. Take a look in your browser console and look at the object that was logged. What information can you see?
***

You will probably also have noticed that the browser reloaded/redirected when we submitted the form - we don't want this behaviour.
It occured because some events have default behaviour associated with them. In this case, submitting a html `form` causes the browser to navigate to a URL with the form values as query parameters.
Thankfully, event objects have a `preventDefault` method attached to them, which exists precisely for occasions like this. Call it in your event handler function, then reload the application and try submitting the form again:


```js
commentForm.addEventListener('submit', function(event) {
  event.preventDefault();
});
```

Now we have prevented the default behaviour of the form, we need to tell it what we *do* want to happen when we submit the form.

What we want to do is get the values from the form inputs, collate them into a comment-shaped object, and send this new object to the API in a POST request. 

```js
commentForm.addEventListener('submit', function(event) {
  event.preventDefault();
  const comment = {
    name: document.getElementById('comment-form-name').value,
    email: document.getElementById('comment-form-email').value,
    body: document.getElementById('comment-form-body').value,
  };
  dataSource.post(`/posts/${postId}/comments`, comment, function(createdComment) {
    console.log(createdComment);
  });
});
```
Here we are selecting the name input element by its id attribute (`comment-form-name`), and retrieving the `value` atribute from the element. We do the same with the email and body inputs, and put these values into an object representing our new comment.

We then use `dataSource.post` to make a POST request to `/posts/${postId}/comments`, with the comment object passed as the request body.

***
### Try it out!
Reload your page again, and re-submit the form. Take a look at the network tab in your browser developer tools. Can you see the request being sent. What data are we sending, and what is the response we are receiving?
***

So we can successfully create a comment on a post. But that comment isn't showing up after we post it.

We now need to re-render the page with the new comment added to the existing array of comments:

```js
dataSource.post(`/posts/${postId}/comments`, comment, function(createdComment) {
  comments.push(createdComment);
  dom.render(PostPage(post, comments));
});
```

***
### Try it out!
Reload your page again, and re-submit the form. You should now see the new comment being added to the list of comments. ðŸ™Œ
***

The final problem we have to solve is what happens when we submit the form more than once - give it a go and see. We are back to the default behaviour of the form, before we added the event handler and prevented the default behaviour.

**Can you think why this might be?**

When we re-render the page, we are actually re-rendering everything inside of the `#root` div. Every element inside of the `#root` div is deleted, and replaced with the new HTML. So the `<form>` that we see after the re-render is not the same one that we submitted before the re-render. This means it does not have the event listener attached to it.

This means we need to attach the event listener to this new version of the form.

If our current code looks like this:

```js
dom.render(PostPage(post, comments));
let commentForm = document.getElementById('comment-form');
commentForm.addEventListener('submit', function(event) {
  event.preventDefault();
  const comment = {
    name: document.getElementById('comment-form-name').value,
    email: document.getElementById('comment-form-email').value,
    body: document.getElementById('comment-form-body').value,
  };
  dataSource.post(`/posts/${postId}/comments`, comment, function(createdComment) {
    comments.push(createdComment);
    dom.render(PostPage(post, comments));
  });
});
```

Then attaching the event listener again might look like this:

```js
dom.render(PostPage(post, comments));

let commentForm = document.getElementById('comment-form');
commentForm.addEventListener('submit', function(event) {
  event.preventDefault();
  const comment = {
    name: document.getElementById('comment-form-name').value,
    email: document.getElementById('comment-form-email').value,
    body: document.getElementById('comment-form-body').value,
  };
  dataSource.post(`/posts/${postId}/comments`, comment, function(createdComment) {
    comments.push(createdComment);
    dom.render(PostPage(post, comments));
    // repeat the code from above to reattach the event listener to the form after re-rendering
    commentForm = document.getElementById('comment-form');
    commentForm.addEventListener('submit', function(event) {
      event.preventDefault();
      const comment = {
        name: document.getElementById('comment-form-name').value,
        email: document.getElementById('comment-form-email').value,
        body: document.getElementById('comment-form-body').value,
      };
      dataSource.post(`/posts/${postId}/comments`, comment, function(createdComment) {
        comments.push(createdComment);
        dom.render(PostPage(post, comments));
      });
    });
  });
});
```

This approach 1) is repetitive, and 2) will only allow us to submit the form twice before it breaks again.

If we wanted to submit the form 3 times, this approach would end up looking like this:

```js
dom.render(PostPage(post, comments));

let commentForm = document.getElementById('comment-form');
commentForm.addEventListener('submit', function(event) {
  event.preventDefault();
  const comment = {
    name: document.getElementById('comment-form-name').value,
    email: document.getElementById('comment-form-email').value,
    body: document.getElementById('comment-form-body').value,
  };
  dataSource.post(`/posts/${postId}/comments`, comment, function(createdComment) {
    comments.push(createdComment);
    dom.render(PostPage(post, comments));
    // repeat the code from above to reattach the event listener to the form after re-rendering
    commentForm = document.getElementById('comment-form');
    commentForm.addEventListener('submit', function(event) {
      event.preventDefault();
      const comment = {
        name: document.getElementById('comment-form-name').value,
        email: document.getElementById('comment-form-email').value,
        body: document.getElementById('comment-form-body').value,
      };
      dataSource.post(`/posts/${postId}/comments`, comment, function(createdComment) {
        comments.push(createdComment);
        dom.render(PostPage(post, comments));
        // repeat the code from above to reattach the event listener to the form after re-rendering
        commentForm = document.getElementById('comment-form');
        commentForm.addEventListener('submit', function(event) {
          event.preventDefault();
          const comment = {
            name: document.getElementById('comment-form-name').value,
            email: document.getElementById('comment-form-email').value,
            body: document.getElementById('comment-form-body').value,
          };
          dataSource.post(`/posts/${postId}/comments`, comment, function(createdComment) {
            comments.push(createdComment);
            dom.render(PostPage(post, comments));
          });
        });
      });
    });
  });
});
```

:scream_cat: :scream_cat: :scream_cat: We obviously need a new approach.

The repetition of the code here is an indication that we can bring the repeated code out into a function:

```js
const dom = new DOM('#root');
const dataSource = new DataSource('https://jsonplaceholder.typicode.com');

const queryParams = new URLSearchParams(window.location.search);
const postId = queryParams.get('id');

// the code in this function was repeated mutiple times in the above example
// it needs to be invoked every time we re-render the dom
// by putting it into a function, we only need to write the code once
function attachFormEventListener(post, comments) {
  const commentForm = document.getElementById('comment-form');
  commentForm.addEventListener('submit', function(event) {
    event.preventDefault();
    const comment = {
      name: document.getElementById('comment-form-name').value,
      email: document.getElementById('comment-form-email').value,
      body: document.getElementById('comment-form-body').value,
    };
    dataSource.post(`/posts/${postId}/comments`, comment, (createdComment) {
      comments.push(createdComment);
      dom.render(PostPage(post, comments));
    });
  });
}

dataSource.get(`/posts/${postId}`, function (post) {
  dataSource.get(`/posts/${postId}/comments`, function(comments) {
    dom.render(PostPage(post, comments));
    attachFormEventListener(post, comments); // we invoke the function here
  });
});
```

Putting the logic into a function is a step in the right direction, but the function is still only called once, after the initial re-render. We need it to be invoked after every re-render.

To achieve this, we can use a technique called **recursion**. This is basically where a function invokes itself in order to perform the same task multiple times.

With recursion we need to be careful - allowing a function to call itself is probably the easiest way of creating an infinite loop. We need to control the conditions under which the function can call itself, so it doesn't just invoke itself automatically over and over again.

Consider the following code example, which would (attempt to) `console.log` every number from 0 to infinity (run this code at your peril...):

```js
function infiniteLog(number) {
  console.log(number);
  infiniteLog(number + 1);
}

infiniteLog(0);
```

To limit how high we want the logging to go (lets say 100), we could modify it like this (feel free to run this one!):

```js
function finiteLog(number) {
  console.log(number);
  if (number <= 100) {
    finiteLog(number + 1);
  }
}

finiteLog(0);
```

In our case, we only want the function to be called again in the case that the form has been submitted and the page has re-rendered. To do this we should add the recursive call into the event handler, after the re-render.

Because the event handler is only triggered when the form is submitted, our recursive adding of new event-handlers will only happen after the form is submitted.

To finish off, update the `attachFormEventListener` function as follows:

```js
...
dataSource.post(`/posts/${postId}/comments`, comment, (createdComment) {
  comments.push(createdComment);
  dom.render(PostPage(post, comments));
  attachFormEventListener(post, comments));
});
...
```

This will now add the missing event handlers to the new form elements whenever they are re-rendered, and it will do it no matter how many times we submit the form.
